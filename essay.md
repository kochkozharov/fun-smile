# Приёмы функционального программирования

Исследование методов программирования является важным шагом в изучении программирования. Они бывают разные, но в данном курсе мы изучаем функциональное программирование. Оно представляет собой парадигму, основанную на вычислении значений функций для решения задач. Основные принципы функционального программирования - это неизменяемость данных, отсутствие побочных эффектов и использование функций в качестве основы программы.
Среди приёмов функционального программирования можно выделить чистые функции, рекурсию, функции высших порядков и так далее. Они способствуют написанию более чистого, понятного и эффективного кода.
В ходе выполнения лабораторной работы по написанию небольшого функционального языка на F# нам довелось применить описанные выше приёмы для выполнения задачи. Использование приёмов функционального программирования позволило нам создать довольно надёжную модульную программу в небольшие сроки.
Нам кажется, что изучать функциональное программирование необходимо хотя бы потому, что оно учит писать программы определённым образом, что может повысить его выразительность, эффективность и надёжность. Для подкрепления данного тезиса рассмотрим приёмы более детально.

Чистой функцией называется функция, которая обладает следующими свойствами: детерминированность и отсутствие побочных эффектов. Первое означает, что функция при одних и тех же входных данных всегда возвращает один и тот же результат. Второе - что функция не меняет внешние данные и никак от них не зависит. Написание таких функций даёт определённые преимущество. Во-первых, повышается предсказуемость, определённость программы, что упрощает отладку и увеличивает её надёжность. Во-вторых, такие функции более гибкие и они легче поддаются параллелизму. Основной проблемой многопоточных программ является их собственно написание. Программисту постоянно необходимо следить за тем, к какой области памяти, к каким переменным обращается тот или иной поток, что очень сложно. Он регулярно будет совершать ошибки, которые ещё и сложно отловить. В таком случае функции, которые работают только с входными данными и ничего не делают снаружи себя - это весьма полезная вещь.
С другой стороны, функция, не взаимодействующая с внешними ресурсами и являющаяся как бы изолированной, имеет недостаток в виде усложнения работы с файловыми системами, базами данных, потоками ввода-вывода и так далее. Также ввиду того, что чистая функция вместо изменения уже существующих данных должна создать новое значение, возможно избыточное использование памяти.
Мы видим, что чистые функции являются мощным приёмом улучшения качества кода и особенно многопоточных программ.

Функцией высших порядков называется функция, которая может принимать другие функции в качестве аргументов, а также возвращать их в виде результата работы. Это означает, что функция является объектом, "рядовым солдатом". Её можно присваивать переменным, передавать в другие функции и так далее. Так данный приём позволяет работать на более абстрактном уровне, оставляя реализацию и другие вещи, что называется, под капотом, он способствует написанию более гибкого, мощного и выразительного кода.
Ещё благодаря функциям высших порядков можно писать более декларативный код даже в императивных языках. Вместо того чтобы описывать конкретные действия, мы можем сказать "мне нужно получить вот это, причём оно должно быть вот таким". Это способствует уменьшению количества строк кода и повторения каких-то монотонных действий вроде постоянных переборов в цикле различных контейнеров.
Однако у данного приёма есть и свои недостатки. Во-первых, ввиду повышения уровня абстракции некоторые программисты могут начать испытывать сложности с понимаем программы. Можно сказать, что существует некоторая грань, переступив которую, можно превратить код из понятного и компактного в нагромождённый и непонятно как работающий.
В итоге данный приём также является полезным и мощным инструментом, который при правильном использовании может сделать ваш код более компактным, понятным и переиспользуемым.

Теперь рассмотрим рекурсию. В отличие от предыдущих приёмов с этим знакомо большинство программистов, даже не изучавших отдельно функциональное программирование. Под рекурсией мы понимаем механизм, который позволяет функции вызывать саму себя для решения определённой задачи. В функциональных языках, таких как F#, рекурсия играет важную из-за отсутствия циклов как таковых.
Главным достоинством рекурсии является возможность абстрагироваться от деталей реализации при решении задачи. К примеру, различные обходы деревьев всегда проще реализовать при помощи рекурсии, так как в таком случае код получается более интуитивным, коротким и понятным: посмотри текущий узел, затем перейди в левый и так далее. Конечно, эти алгоритмы можно и иногда нужно реализовать при помощи циклов, стеков и очередей - это может быть необходимо в следствие ограниченности памяти - однако такие алгоритмы, как правило, более сложны и менее понятны.
Но не стоит забывать и о недостатках данного приёма. Рекурсия часто приводит к избыточному потреблению памяти и снижению производительности ввиду накладных расходов на создание новых контекстов выполнения для каждого вызова функции, а в случаях, когда рекурсия оказывается слишком глубокой, например, при работе с большими объёмами данных, может и вовсе происходить переполнения стека - он же всем известный stack overflow. Также использование рекурсии может привести к усложнению процесса отладки, так как работа рекурсии не совсем очевидна для программиста, чем те же циклы.
Конечно, существуют методы решения этих проблем вроде использования хвостовой рекурсии, однако они не всегда применимы.
В конечном счёте мы имеем инструмент, который нужно уметь правильно и вовремя применить, однако взамен мы получаем возможность писать более компактный и понятный код, в особенности при работе с рекурсивными структурами данных и контейнерами.

Ещё одной особенностью функционального программирования является неизменяемость данных. Это концепция подразумевает, что после создания данные не могут быть изменены, то есть любое взаимодействие с ними представляет собой создание новых данных. Это напоминает ячейки с данными в Excel, с помощью которых можно производить вычисления, но только путём создания новых ячеек на основе существующих. Очевидно, это довольно расточительно с точки зрения используемой памяти. При работе с большими объёмами данных это может привести к излишнему потреблению памяти и снижению производительности, что является главным недостатком данной концепции. Однако этот приём позволяет получить и некоторые преимущества.
При неизменяемых данных мы имеем возможность избежать множества возможных ошибок, которые связаны с изменением состояния памяти. Все помнят шутку про Си, работу с памятью и выстрел в ногу. Так как мы исключили случайные изменения памяти в разных частях кода, программа становится более предсказуемой и отлаживаемой. Это также полезно при разработке многопоточных программ, о которых говорилось ранее, ввиду отсутствия необходимости в синхронизации доступа к памяти из разных потоков.
Таким образом, данный приём может оказаться весьма полезным в тех областях, где требуется написание предельно безопасных и предсказуемых программ.

Итак, после детального обзора основных приёмов функционального программирования перейдём описанию более конкретных инструментов, которые мы использовали при выполнении лабораторной работы.

При реализации парсера весьма полезным оказался паттерн-мэтчинг. Это инструмент языка F#, который позволяет очень удобно обрабатывать различные случаи и варианты значений. Это словно механизм swtich case, но с большим количеством возможностей, например, сопоставление по типу, по образцу и так далее. Благодаря ему нам удалось довольно просто описывать различные варианты синтаксических конструкций и правильно их обрабатывать. При этом он позволяет писать весьма минималистичный и читаемый код, который к тому же легко отлаживать, потому что компилятор F# проверяет возможные варианты сопоставления паттернов. Это позволяет избежать ошибок заранее - на этапе компиляции.

Ключевым приёмом для реализации различных структур данных для нашего языка стало использование алгебраических типов данных в виде декартового произведения типов или их прямой суммы. Этот инструмент позволяет описывать структуры данных, которые могут принимать одно из нескольких значений. Это очень полезно, когда нужно описывать различные выражения, переменные, операторы и тому подобное. Он обеспечивает высокую безопасность благодаря возможности выявления ошибок на этапе компиляции. В паре с паттерн-мэтчингом алгебраические типы данных становятся ещё более мощным инструментом, так как их можно разбивать на значения и обрабатывать по частям. Это очень сильно упростило разработку парсера.

Также при написании парсера активно использовались парсерные комбинаторы. Они позволяют объединять простые парсеры в более сложные. Это позволяет собирать нужный нам парсер из так называемых модулей - более простых парсеров - чтобы затем разбивать введённый пользователь исходных код и создавать структурированное представление данных. Также библиотека FParsec предоставляет возможности для рекурсивного парсинга, которая чрезвычайно необходимо для обработки исходного кода. По крайней мере, без данной библиотеки это была бы весьма непростая задача. Преимуществом данного приёма является простота, гибкость и модульность. Так как грамматика описывается в виде кода на языке программирования, нет необходимости использовать отдельные зависимости или программы вроде lex и yacc для описания синтаксиса разрабатываемого языка. Благодаря этому мы имеем возможность писать парсер просто и быстро.

Подведём итоги. Мы рассмотрели различные приёмы функционального программирования, а также конкретные примеры инструментов, использованных в лабораторной работе. Исходя из вышесказанного, можно сделать вывод, что функциональное программирование весьма полезно для решения множества задач.
Важно отметить, что при правильном использовании различные приёмы из данной парадигмы могут быть применены также в императивных языках, что позволяет создавать красивые, компактные, надёжные и эффективные решения. Главное, как и с любым инструментом, необходимо учитывать особенности конкретной задачи и адаптировать приёмы под текущие нужды.
